\documentclass[12pt, titlepage]{article}

\usepackage[boldfont]{xeCJK}
\usepackage{mathtools}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{mathpartir}
\usepackage[left=2.5cm, right=2.5cm,bottom=5cm]{geometry}
\usepackage{syntax}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{indentfirst}
\usepackage{graphicx}   

\setmainfont[Scale=1.08]{Charter}
\setCJKmainfont[Scale=1.15]{STSong}
\setCJKfamilyfont{kai}{Kaiti SC}

\newfontfamily\listingsfont{PT Mono}

\lstset{
	numbers = left,
	numberstyle=\footnotesize,
	xleftmargin=2em, xrightmargin=2em,aboveskip=2em,tabsize=4,
	basicstyle=\listingsfont\linespread{0.1},	
	frame=tb,
	keywordstyle=\bfseries\color{blue},
	commentstyle=\itshape\color{green},
	numberstyle=\color{black}
}

\lstdefinelanguage{Ocaml}{morekeywords={fun, let, in,if,then,else}}

\newtheorem{definition}{定义}
\linespread{1.8}
\setlength{\footskip}{60pt}

\newcommand{\xto}{\xrightarrow}
\let\emptyset\varnothing

\title{基于类型系统的Haskell控制流分析框架}
\author{罗翔宇\\北京大学}

\begin{document}
	\maketitle
	\section{背景介绍}
	在实际软件工程项目的开发过程中，如果能够仅通过审查代码的方式（而非真正使用计算机运行程序）来获取程序的一些性质，从而进行漏洞排查、冗余代码移除或项目的其它优化，是一项非常有意义的事情。而这种只审查代码来推导程序性质的方式，就称之为程序的静态分析。由于其在项目开发中的重要作用，程序静态分析一直是软件工程研究领域的热点之一。
	
	近些年来，基于$\lambda$演算的函数式编程语言逐渐开始流行开来。函数式编程语言相对于传统的命令式编程语言，更加强调程序执行的结果而非程序执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。因此，函数式语言更加抽象，表达能力更为强大，同时也为在函数式语言上做程序静态分析带来了更大的挑战。
	
	一般情况下，函数式编程语言上的程序静态分析通常以控制流分析为主，即确定每一个函数的调用目标，同时控制流分析也是函数式编程语言上其他的静态分析的基础。举一个例子，考虑如下程序片段：
	\begin{lstlisting}[language=Ocaml]
  let f = fun g -> g True
  in f (fun x -> if x then False else True)
	\end{lstlisting}
	通过控制流分析，我们可以知道调用f时对应的目标为在let 绑定语句中的$\mathrm{fun}\ \mathrm{g} \to \mathrm{g}\ \mathrm{True}$。一旦有了函数的调用目标的结果，我们就可以执行后续的程序切片、数据依赖等分析。事实上，为了解决函数式语言的控制流分析，程序分析的研究学者们已经提出了若干优秀的算法，比如基于抽象解释的kCFA算法。虽然已有的算法能够在相对可以接受的时间内给出较为精确的结果，但是在实际应用中也有一定的局限性，主要体现在以下方面：
	\begin{itemize}
		\item \textbf{函数式语言的求值顺序。}对于函数式语言的控制流分析，一个不可忽视的问题是求值顺序对于分析结果的影响。求值顺序在普通的命令式编程语言中通常可以直接在控制流分析的结果中体现出来，这是因为命令式语言的求值顺序就是编程人员字面书写的代码语句的顺序，但是在传统函数式编程的研究中，lambda 演算的求值语义往往定义为beta规约，这种规约并没有指定求值的顺序，不同的编译器有不同的实现方式，通常有按值调用、按名字调用和按需求调用等。除此之外，编译器在编译时期基于beta分析进行的编译优化或是程序的并行执行，都会影响控制流分析的结果。而基于抽象解释的控制流分析技术，往往需要针对不同的求值顺序的实现而做相应的更改，没有很好的通用性。
		\item \textbf{控制流分析算法的运行效率。}传统的基于抽象解释的控制流分析通常是模拟一个抽象解释器，在非确定性自动机上做推演规约。而这个推演规约过程的渐进时间复杂度是非多项式的，对于一些规模较大的程序，运行时间无法接受。除此之外，基于抽象解释的分析往往需要在编译器进行过类型检查之后，再次扫描整个程序并进行分析，无法很好的利用之前类型分析的结果，这也是时间效率低下的原因之一。
		\item \textbf{控制流分析的模块化。}随着计算机技术的发展，实际的软件开发项目越来越庞大，代码也越来越复杂，模块化已经成为项目代码组织的基本原则之一。而基于抽象解释的分析却不能够很好的支持项目的模块化，即无法重用已有的代码的分析结果，如果某个代码片段稍作修改，有的项目都需要重新分析，这样就造成计算资源和时间的极大浪费。
	\end{itemize}
	Christian Mossin在他的论文中，提出了一个基于类型系统的函数式语言控制流分析，有效地解决了上文中现有控制流分析的种种问题。不过他的原始算法只适用于简单的静态类型$\lambda$演算，且最终结果分析的步骤过于繁琐。本文尝试将其算法扩展到了所有支持Hindley-Milner类型系统的编程语言，并包括let多态，函数参数类型重建以及代数数据结构等现代函数式语言必备的特性，除此之外，还优化了Christian的算法中分析结果的步骤，使得整个算法更加简洁。
	
	为了进一步证明该算法的易用性，同时也为了改善函数式语言编程社区静态分析工具匮乏的现状，笔者尝试将以上优化的算法在Haskell语言上进行实现。
	
	Haskell语言作为函数式编程语言的代表，拥有一个基于Hindley-Milner类型推论的静态强类型系统，同时支持惰性求值、模式匹配、列表解析和类型多态等特性。Haskell的这些复杂的特性为在其上进行控制流分析带来了巨大的挑战。到目前为止，Haskell语言上的静态分析工具依然十分稀少，并且现有的工具的分析结果都不尽人意。其中一个例子是已经广泛使用的SourceGraph工具，它的控制流分析结果是非常粗糙的。比如考虑如下代码片段：
	\begin{lstlisting}[language=haskell]
	f x = x 3
	g y = f (\t -> t + y)
	\end{lstlisting}
	SourceGraph只能推断出g函数依赖于f函数，却无法准确地分析出f函数的的定义里$\mathrm{x\ 3}$的函数调用依赖于$\mathrm{\\t -> t + y}$的定义，即SourceGraph的控制流分析结果只停留在词法层面，而非语义层面的分析，这样的精准度对于实际应用是远远不够的。Haskell语言上另外一个控制流分析框架是shivers-cfg，但是它的开发目前已经停滞，而且根据文档的介绍，现有的代码只是对Shivers算法简单的实现，甚至没有为用户提供API接口，所以目前还无法测试其精准度。
	
	\section{语言定义}
	出于方便起见，我们首先定义自己的一个带有Hindley-Milner类型系统的简单编程语言。为了更好地揭露算法的本质，避免无关紧要的细节对于读者理解算法的影响，我们希望这个语言的语法尽可能简洁，同时又能保留静态类型系统、多态等特性。注意本章的语言仅用于说明算法，真正的代码在Haskell语言上实现。
	
	首先令$V$是一个可列举的变量集合，同时令$x, y, z$为$V$中的元素。一个程序即为如下一个表达式：
	\setlength{\grammarindent}{8em} % increase separation between LHS/RHS 
    \begin{grammar}
        <term> ::= <variable>
        \vspace{0.3em}
        \alt $\lambda$ <variable>.<term>
        \vspace{0.3em}
        \alt <term> <term>
        \vspace{0.3em}
        \alt fix <variable>.<term>
        \vspace{0.3em}
        \alt let (<variable>, <variable>) be <term> in <term>
        \vspace{0.3em}
        \alt let <variable> = <term> in <term>
        \vspace{0.3em}
        \alt if <term> then <term> else <term>
        \vspace{0.3em}
        \alt True
        \vspace{0.3em}
        \alt False
        \vspace{0.3em}
        \alt\{0, 1, 2, $\cdots$\}
	\end{grammar}
	他们的含义分别为:
	\begin{itemize}
	  \setlength\itemsep{0.1em}
		\item $x$ 即为一个单独的变量
		\item $\lambda x.e$定义一个函数接受一个参数x，函数体为e. 多参函数可以使用嵌套的$\lambda$定义实现。注意这里没有声明x的类型，即x的类型由e中对于x的类型约束而重建出。
		\item $e_1\ e_2$ 函数应用，将e1作用于e2
		\item $\mathrm{fix}\ x.e$利用fix组合子来定义一个递归函数
		\item $(e, e’)$ 一个元组，可以使用let be模式匹配来分别绑定到不同的变量
		\item $\mathrm{let}\ (x, y)\ \mathrm{be}\ e\ \mathrm{in}\ e’$ 元组的模式匹配。其中e必须为一个元组，而在e’中x被绑定为e的第一项，y被绑定为e的第二项。
		\item $\mathrm{let}\ x = e\ \mathrm{in}\ e’$ 变量的let绑定，注意这里有let多态，即x在e’中只有一个type schema, 具体的类型会在x使用时进行实例化。
		\item $\mathrm{if}\ e\ \mathrm{then}\ e’\ \mathrm{else}\ e’’$ if条件语句，这里e的类型必须是Bool型，e’和e’’必须有相同的类型。
		\item $\mathrm{True}, \mathrm{False}, \{0, 1, 2…\}$字面量，分别对应Bool真假常量和自然数。
	\end{itemize}	
在我们的编程语言中，定义如下的类型系统：	
	\begin{mathparpagebreakable}
		\inferrule{x:t \in A}{A\vdash x:t\mid \emptyset}\qquad \mathrm{Id}\and
		\inferrule{\mathrm{X\ is\ a\ fresh\ type\ variable}\quad A, x:X\vdash e:T\mid C}{A\vdash\lambda x.e:X\to T\mid C}\qquad\mathrm{Abs}\and
		\inferrule{A\vdash t_1:T_1\mid C_1\quad A\vdash t_2:T_2\mid C_2\quad \mathrm{X\ is\ a\ fresh\ type\ variable}}{A \vdash t_1\ t_2:X\mid C_1\cup C_2\cup \{T_1 = T_2\to X\}} \qquad\mathrm{App}\and
		\inferrule{\mathrm{X\ is\ a\ fresh\ type\ variable}\quad A, x:X_1\vdash e:X_2\mid C}{A\vdash \mathrm{fix}\,x.e:X_1\mid C\cup\{X_1=X_2\}}\qquad\mathrm{Fix}\and
		\inferrule{A\vdash e_1:T_1\mid C_1\quad A\vdash e_2:T_2\mid C_2}{A\vdash (e_1, e_2):(T_1, T_2)\mid C_1\cup C_2}\qquad\mathrm{Tuple}\and
		\inferrule{A\vdash e:(T_1, T_2)\mid C_1\quad A,x:T_1,y:T_2\vdash e':T\mid C_2}{A\vdash \mathrm{let}\ (x,y)\ \mathrm{be}\ e\ \mathrm{in}\ e':T\mid C_1\cup C_2}\quad\mathrm{Tuple\ Deconstruct}\and
		\inferrule{A\vdash[x\mapsto t_1]t_2:T_2 \mid C}{A\vdash \mathrm{let}\ x=t_1\ \mathrm{in}\ t_2:T_2\mid C}\qquad\mathrm{Let}\and
		\inferrule{A\vdash e_1:\mathrm{Bool}\mid C_1\quad A\vdash e_2:t\mid C_2\quad A\vdash e_3:t\mid C}{A\vdash\mathrm{if}\ e_1\ \mathrm{then}\ e_2\ \mathrm{else}\ e_3:t\mid C_1\cup C_2\cup C_3}\qquad\mathrm{If}\and
		\inferrule{}{\mathrm{True:Bool}\mid \emptyset}\qquad\mathrm{True}\and
		\inferrule{}{\mathrm{False:Bool}\mid \emptyset}\qquad\mathrm{False}\and
		\inferrule{x\in\{0, 1, 2, \cdots\}}{A\vdash x:\mathrm{Int}\mid\emptyset}\qquad\mathrm{Int}
	\end{mathparpagebreakable}
	其中A为类型的上下文，C为HM类型系统中产生的约束集合，最终使用联合算法解所有的约束从而得到一个从类型变量到实际类型的替换函数，将这个替换函数应用到表达式所推导的类型即可得到表达式真实的类型。每一条类型规则的解释如下：
	\begin{itemize}
		\item \textbf{Id} 如果一个变量的已经在类型上下文中有记录，直接取出记录即可，约束为空。
		\item \textbf{Abs} 对于一个定义的$\lambda$函数，如果给其参数x一个类型变量X，同时A并上x是X类型的前提下可以推导出e是类型T和约束集合C，那么定义的函数即为X $\to$ T类型，同时给出约束C。
		\item \textbf{App} 给定一个函数应用，如果第一个表达式是$T_1$类型，第二个表达式是$T_2$类型，那么可以知道$T_1$必然是是$T_2\to X$的形式，于是可以在约束集合中添加约束$\{T_1 = T_2\to X\}$，且整个表达最终返回的类型为X
		\item\textbf{Fix} Fix即为$\lambda$演算中的不动点组合子，用来解决递归函数的情况。由于fix组合子的定义中，传入参数的类型实际上是和函数体的类型等价，所以直接在约束集合中添加约束$\{X_1 = X_2\}$即可。
		\item\textbf{Tuple} 如果一个元组第一分量的类型是$T_1$，第二分量的类型是$T_2$，那么整个元组的类型即为$(T_1, T_2)$
		\item\textbf{Tuple Deconstruct} 元组的模式匹配本质上是将元组的第一分量和第二分量都绑定到一个变量, 然后将绑定过后的变量添加进类型环境，最终在新的类型环境下推导出e的类型。
		\item\textbf{Let} 为了实现let多态，我们不能简单地推导出t1 的类型并将x添加进类型环境中，而是应在e中将所有的x出现的地方替换为t1 后推导出e的类型。
		\item\textbf{If} 首先需要保证用于条件判断的表达式e1是Bool类型，另外一个条件就是if语句的then分支和else分治的类型应当一致。所以将这两个约束添加进约束集合即可
		\item\textbf{True, False, Int} 对于所有的字面量，直接返回该字面量对应的类型
	\end{itemize}
	
\section{算法框架}
有了语法和类型系统的定义之后，我们接下来就可以形式化地定义在该语言上的控制流分析。
\subsection{标号和流属性}
	令$V$为一个无穷可列集合，对于任意$V$中元素$l$，称$l$为一个标号。 定义一个标号集合$\ell$为流属性，即$\ell\subset V$. 对于任意一个表达式$e$, 为$e$中所有形如$\lambda x.e$, $True$, $False$, $\{1, 2, 3,\cdots\}$的子表达式分配一个独一无二的标号。如表达式$$\mathrm{if}\ True\ \mathrm{then}\ \lambda x.x\ \mathrm{else}\ \lambda y.0$$分配过标号之后为$$\mathrm{if}\ True^{l_1}\ \mathrm{then}\ \lambda^{l_2} x.x\ \mathrm{else}\ \lambda^{l_3} y.0^{l_4}$$
\subsection{流属性变量和流属性约束}
我们定义形如$\alpha, \beta, \gamma$的变量为一个流属性变量，可以指代任一流属性。 一个流属性约束为形如$\alpha\subset\beta$ 的约束，表示$\alpha$ 是$\beta$ 的子集。我们用C来代指一个流属性约束组成的集合。
\subsection{流属性类型}
我们基于Hindey-Milner类型系统定义如下流属性类型：
	\begin{mathpar}
		\inferrule{\kappa\in\mathcal{K}(t)\quad\kappa'\in\mathcal{K}(t')}{\kappa\xto{\ell}\kappa'\in\mathcal{K}(t\to t')}\qquad\mathrm{Arrow}\and
		\inferrule{\kappa\in\mathcal{K}(t)\quad\kappa'\in\mathcal{K}(t')}{(\kappa, \kappa')^\ell\in\mathcal{K}((\kappa, \kappa'))}\qquad\mathrm{Tuple}\and
		\inferrule{\kappa\in\mathcal{K}(t)}{\forall \vec{X}.\kappa\in\mathcal{K}(\forall \vec{X}.t)}\qquad\mathrm{Type Forall}\and
		\inferrule{\forall\vec{X}.\kappa\in\mathcal{K}(\forall\vec{X}.t)}{\forall\vec{\alpha}.C\Rightarrow\forall\vec{X}.\kappa\in\mathcal{S}(\forall\vec{X}.t)}\qquad\mathrm{Flow Property Forall}\and
		\inferrule{}{\mathrm{Bool}^\ell\in\mathcal{K}(\mathrm{Bool})}\qquad\mathrm{Bool}\and
		\inferrule{}{\mathrm{Int}^\ell\in\mathcal{K}(\mathrm{Int})}\qquad\mathrm{Int}
		\qquad\kappa\,[\vec{\alpha}/\vec{l}\,]
	\end{mathpar}
对于原语言中任意一个类型t，$\mathcal{K}(t)$是由类型$t$扩展出的流属性类型的集合，这个集合中任一元素$\kappa$在删除掉其绑定的流属性之后，就得到原类型$t$. 定义函数$\mathcal{L}$为从流属性类型到流属性的函数，即提取出最外层绑定的流属性，定义如下：
	\begin{align*}
		&\mathcal{L}(Bool^\ell) = \ell\\
		&\mathcal{L}(Int^\ell) = \ell\\
		&\mathcal{L}(\kappa_1\xto{\ell}\kappa_2)=\ell\\
		&\mathcal{L}((\kappa_1, \kappa_2)^\ell)=\ell
	\end{align*}
	
	对于形如$\forall\vec{\alpha}.C\Rightarrow\forall\vec{X}.\kappa$的流属性类型，我们称其为一个流属性类型模式，其中C为一个约束集合，$\vec{\alpha}$是一系列的流属性变量，$\vec{X}$为一系列类型变量。$\forall\vec{\alpha}.C\Rightarrow\forall\vec{X}\kappa$的意义是一个表达式对于所有使得C成立的流属性$\vec{l}$，有类型$\forall\vec{X}.\kappa[\vec{\alpha}/\vec{l}]$，即将$\kappa$中所有的$\vec{\alpha}$替换为$\vec{l}$。我们用$\tau$来表示流属性模式， $\mathcal{S}(t)$是一个流属性类型模式集合。
\subsection{流属性类型的子类型关系}
对于流属性类型，我们有如下流属性子类型关系：
	\begin{mathpar}
		\inferrule{\ell_1\subseteq\ell_2}{\mathrm{Bool}^{\ell_1}\preceq\mathrm{Bool}^{\ell_2}}\qquad \mathrm{Sub Bool}\and
		\inferrule{\ell_1\subseteq\ell_2}{\mathrm{Int}^{\ell_1}\preceq\mathrm{Int}^{\ell_2}}\qquad \mathrm{Sub Int}\and
		\inferrule{\kappa_1\preceq\kappa_1'\quad\kappa_2\preceq\kappa_2'\quad\ell_1\subseteq\ell_2}{\kappa_1'\xto{\ell_1}\kappa_2\preceq\kappa_1\xto{\ell_2}\kappa_2'}\qquad\mathrm{Sub Arrow}\and
		\inferrule{\kappa_1\preceq\kappa_1'\quad\kappa_2\preceq\kappa_2'\quad\ell_1\subseteq\ell_2}{(\kappa_1,\kappa_2)^{\ell_1}\preceq(\kappa_1', \kappa_2')^{\ell_2}}\qquad\mathrm{Sub Tuple}
	\end{mathpar}
\subsection{流属性类型系统}
	\begin{definition}[替换]
		对于任意流属性类型$\kappa$，定义$\kappa[\vec{\alpha}/\vec{l}\,]$为将$\kappa$中出现的所有流属性变量$\vec{\alpha}$替换为$\vec{l}$，定义$\kappa[\vec{X}/\vec{T}\,]$为将$\kappa$中出现的所有类型变量$\vec{X}$替换为$\vec{T}$
	\end{definition}
	\begin{definition}[环境]
		定义由形如$x:\tau$组成的集合为一个环境，表示变量$x$有类型$\tau$, 其中流属性约束变量向量$\vec{\alpha}$、流属性约束集合$C$和类型约束变量$\vec{X}$均可以是空集。定义$Type(A)$为环境中所有流属性类型模板组成的集合，$Var(A)$为环境中所有变量组成的集合.
	\end{definition}
	\begin{definition}[$FV_t$]
		对于一个流属性类型$\kappa_i$，定义其中所有出现的类型变量的集合为$FV_t(\kappa)$. 对于一个环境A，定义$FV_t(A) = \bigcup FV_t(\kappa_i),\quad \forall\kappa_i\in Type(A)$
	\end{definition}
	\begin{definition}[$FV_f$]
		对于一个流属性类型$\kappa_i$，定义其中所有出现的流属性变量的集合记为$FV_f(\kappa)$. 对于一个环境A，定义$FV_f(A) = \bigcup FV_f(\kappa_i),\quad \forall\kappa_i\in A$. 对于一个流属性约束集合$C$, 定义$FV_f(C)$为所有出现在此约束集合中的流属性变量.
	\end{definition}
	\begin{definition}[$free_t$]
		对于一个形如$\forall\vec{\alpha}.C\Rightarrow \forall\vec{X}.\kappa$的流属性类型模式$\tau$和一个环境$A$，定义$$free_t(A, \tau) = FV_t(\kappa) - FV_t(A) - \vec{X}$$
	\end{definition}
	\begin{definition}[$free_f$]
		对于一个形如$\forall\vec{\alpha}.C\Rightarrow \forall\vec{X}.\kappa$的流属性类型模式$\tau$和一个环境$A$，定义$$free_f(A, \tau) = FV_f(\kappa) - FV_f(A) - FV_f(C) - \vec{\alpha}$$
	\end{definition}
	\begin{definition}[$generalize_t$]
		对于一个流属性类型$\kappa$和一个环境$A$，定义$$generalize_t(A, \kappa) = \forall free_t(A, \kappa).\kappa$$. 称形如$\forall free_t(A, \kappa).\kappa$的类型为类型模式，记为$\varphi$
	\end{definition}
	\begin{definition}[$generalize_f$]
		对于一个形如$\forall\vec{X}.\kappa$的类型模式$\varphi$, 一个环境$A$和一个流属性约束集合$C$，定义$$generalize_f(A, C, \varphi) = \forall free_f(A, C, \kappa).C\Rightarrow\forall\vec{X}.\kappa$$
	\end{definition}
	\begin{definition}[$instantiate_f$和$instantiate_c$]
		对于一个形如$\forall\vec{\alpha}.C\Rightarrow\forall\vec{X}.\kappa$流属性类型模式$\tau$和一个环境$A$，定义$$instantiate_f(A, \tau) = \forall\vec{X}.\kappa[\vec{\alpha}/\vec{\beta}]$$$$instantiate_c(A, \tau)=C[\vec{\alpha}/\vec{\beta}]$$ 其中$\beta$为未出现过的流属性变量
	\end{definition}
	\begin{definition}[$instantiate_t$]
		对于一个形如$\forall\vec{X}.\kappa$的类型模式$\varphi$和一个环境$A$，定义$$generalize_t(A, \varphi) = \kappa[\vec{X}/\vec{Y}]$$ 其中$\vec{Y}$为未出现过的类型变量
	\end{definition}
	\begin{definition}[类型约束的解]
		给定一个类型约束集合$D = \{\kappa_1 = \kappa_2, \kappa_3 = \kappa_4, \cdots\}$, 定义$f$是一个由类型变量到类型的映射，定义替换
		\begin{equation*}
			S(\kappa) = 
			\begin{cases}
				S(\kappa_1)\xto{\ell}S(\kappa_2) & \text{if } \kappa = \kappa_1\xto{\ell}\kappa_2\\
				X & \text{if } X = Bool\ \text{or}\ X = Int\ \text{or}\ X\not\in dom(f)\\
				f(X) & \text{if } X\in dom(f)
			\end{cases}
		\end{equation*}
	\end{definition}
	为由$f$生成的替换。如果$\forall\kappa_i=\kappa_j\in D$都有$S(\kappa_i) = S(\kappa_j)$, 称$f$为约束集合$D$的解函数，称$S$为约束集合$D$的解。对于替换$S$我们可以将其推广到形如$\forall\vec{\alpha}.C\Rightarrow\forall\vec{X}.\kappa$流属性模板$\tau$和环境$A$上，即$$S(\tau) = \tau[free_t(\tau)/S(free_t(\tau))]$$$$S(A) = \{x_i:S(\kappa_i)\}\quad\forall x_i:\kappa_i\in A$$
	
	基于以上定义，我们给出如下类型推导规则：
	\begin{mathparpagebreakable}
		\inferrule{x:\tau\in A\quad\mathrm{let}\ \varphi\ \mathrm{be}\ instantiate_f(\tau)\ \mathrm{and}\ C\ \mathrm{be}\ generalize_c(\tau)}{A\vdash x:instantiate_t(\varphi)\mid \emptyset\mid C} \qquad\mathrm{Id}\and
		\inferrule{X\ \mathrm{is\ a\ fresh\ type\ variable}\quad A, x:X\vdash e:\kappa\mid D\mid C}{A\vdash \lambda^{l}x.e:X\xto{\{l\}} \kappa\mid D \mid C}\qquad\mathrm{Abs}\and
		\inferrule{A\vdash e_1:\kappa_1\mid D_1\mid C_1\quad A\vdash e_2:\kappa_2\mid D_1\mid C_1\\ \mathrm{X\ is\ a\ fresh\ type\ variable}\quad\mathrm{\alpha\ is\ a\ fresh\ flow\ properties\ variable}}{A\vdash e_1\ e_2:X\mid D_1\cup D_2\cup \{\kappa_1 = \kappa_2\xto{\alpha} X\}\mid C_1\cup C_2\cup \{\kappa1 \preceq \kappa_2\xto{\alpha}X\}}\qquad\mathrm{App}\and
		\inferrule{\mathrm{X\ is\ a\ fresh\ type\ variable}\quad A,x:\kappa\vdash e:\kappa\mid D\mid C}{A\vdash \mathrm{fix}\,x.e:\kappa\mid C\cup\{\kappa=X\}\mid D\cup\{\kappa\preceq X\}}\qquad\mathrm{Fix}\and
		\inferrule{A\vdash e_1:\kappa_1\mid D_1\mid C_1\quad A\vdash e_2:\kappa_2\mid D_2\mid C_2}{A\vdash (e_1,e_2)^{l}:(\kappa_1, \kappa_2)^{\{l\}}\mid D_1\cup D_2\mid C_1\cup C_2}\qquad\mathrm{Tuple}\and
		\inferrule{A\vdash e:(\kappa_1, \kappa_2)^{\alpha}\mid D_1\mid C_1\quad A,x:\kappa_1,y:\kappa_2\vdash e':\kappa_3\mid D_2\mid C_2}{A\vdash\mathrm{let}\ (x,y)=e\ \mathrm{in}\ e':\kappa_3\mid C_1\cup C_2\mid D_1\cup D_2}\qquad\mathrm{Tuple\ Deconstruct}\and
		\inferrule{A\vdash e:\kappa\mid D\mid C\quad \mathrm{let}\ S\ \mathrm{be\ the\ solution\ of}\ D\quad \\ S(A), x:S(generalize_f(S(A), C, generalize_t(S(A), \kappa)))\vdash e':\kappa'\mid D'\mid C'}{A\vdash\mathrm{let}\ x=e\ \mathrm{in}\ e':\kappa' \mid D\cup D'\mid C\cup C'}\qquad\mathrm{Let}\and
		\inferrule{\mathrm{\alpha\ is\ a\ fresh\ flow\ properties\ variable}\quad X\ \mathrm{is\ a\ fresh\ type\ variable}\\ A\vdash e_1:\kappa_1\mid D_1\mid C_1\quad A\vdash e_2:\kappa_2\mid D_2\mid C_2\quad A\vdash e_3:\kappa_3\mid D_3\mid C_3}{A\vdash \mathrm{if}\ e_1\ \mathrm{then}\ e_2\ \mathrm{else}\ e_3:X \mid D_1\cup\\ D_2\cup D_3\cup \{\kappa_1=Bool^\alpha, \kappa_2=\kappa_3\}\mid C_1\cup C_2\cup C_3\cup \{\kappa_2\preceq X, \kappa_3\preceq X\}}\qquad\mathrm{If}\and
		\inferrule{}{A\vdash True^l:Bool^{\{l\}}\mid\emptyset\mid\emptyset}\qquad\mathrm{True}\and
		\inferrule{}{A\vdash False^l:Bool^{\{l\}}\mid\emptyset\mid\emptyset}\qquad\mathrm{False}\and
		\inferrule{x\in\{1,2,\cdots\}}{A\vdash x^l:Int^{\{l\}}\mid\emptyset\mid\emptyset}\qquad\mathrm{Int}
	\end{mathparpagebreakable}
	其中D为Hindley-Milner系统的类型约束集合，C是子类型约束的集合，用于推导出流属性约束集合。
	\begin{itemize}
	\item \textbf{Id} 对于一个变量x，如果x在当前的环境中有记录为$\tau$流属性类型模式，那么使用未出现的流属性变量和类型变量进行实例化即可
	\item \textbf{Abs} 对于一个lambda函数的定义，如果将x:X添加到当前环境中可以推导出e是$\kappa$类型，且得到类型约束和子类型约束D和C，那么$\lambda x.e$的类型即为$X\to\kappa$，该类型绑定的流属性即为当前$\lambda$表达式标号。  
	\item \textbf{App} 对于函数调用，如果第一个表达式是$\kappa_1$类型，第二个表达式是$\kappa_2$类型，那么可以知道$\kappa_1$必然有形式$\kappa_2 \to X$, 于是将$\{\kappa_1 =  \kappa_2\to X\}$其添加到类型约束集合中，将$\{\kappa_1\preceq\kappa_2\to X\}$添加到子类型约束集合中即可。
	\item \textbf{Fix} 根据Fix组合子的定义，函数体e的类型必须和参数x的类型相同，且其绑定的流属性是参数x绑定的流属性的子集，所以分别往类型约束集合和子类型约束集合中添加$\{\kappa= X\}$和$\{\kappa\preceq X\}$即可。
	\item \textbf{Tuple} 类似于之前的类型推导中Tuple规则，不同的一点是一个Tuple值所绑定的流属性即为这个值的标号本身。
	\item \textbf{Tuple Deconstruct} 类似于之前的类型推导中的Tuple Deconstruct规则，不同的一点是将类型替换为流属性类型即可。
	\item \textbf{If} 在环境A中如果可以推出$e_1$为$T_1$类型，$e_2$为$T_2$类型，$e_3$为$T_3$类型，可以得到类型的约束为$\{T_1 = Bool\}$，且$T_2$和$T_3$去掉流属性之后的类型应当一致。除此之外，还应当存在一个流属性类型X，使得$T_2$为X的子类型同时X也是$T_3$的子类型。将这四条条约束添加进相应的约束集合即可。
	\item \textbf{True, False, Int} 对于字面量，直接得到其对应的类型即可，绑定的流属性即为当前字面量的标号。
	\item \textbf{Let} 为了实现多态，Let的规则比较复杂。首先在环境$A$中推导出$e$表达式的流属性类型$\kappa$以及相对应的类型约束集合$D$和子类型约束集合$C$。注意我们不能直接把推导$e$时得出的类型约束集合并入最终答案中，因为$e$的类型都是多态类型，即其中的类型变量会在以后实例化成新的类型变量，所以我们需要在这里直接求解类型约束集合$D$并将其解$S$应用到当前环境$A$和后续的类型推导中。但是由于子类型约束集合不能部分求解，所以需要在泛化后的流属性类型模式中绑定上子类型约束的集合，即形如$\forall\vec{\alpha}.C\Rightarrow\forall\vec{X}.\kappa$的流属性类型模板。而$e$的类型多态只体现在$\kappa$中自由类型变量和自由流属性变量中，所以只需为其添加约束并在后续使用的位置进行实例化即可。
	\end{itemize}
	
	\subsection{求解类型约束集合}
	在这里我们使用联合算法求解类型约束集合，其中$unify$函数接受一个类型约束集合$D$并返回其一个解$S$。该算法的伪代码描述如下：
	\begin{lstlisting}[escapeinside={`}{`}]
	unify(D) = if C is empty then id
			else let {`$\kappa_1$` = `$\kappa_2$`} `$\cup$` C' = C in
				if `$\kappa_1$` = `$\kappa_2$` 
					then unify(C')
				else if `$\kappa_1$` is X and X `$\not\in$` FV(`$\kappa_2$`) 
					then unify(C'[X/`$\kappa_2$`]) `$\circ$` [`$X\mapsto\kappa_2$`]
				else if `$\kappa_2$` is X and X `$\not\in$` FV(`$\kappa_1$`)
					then unify(C'[X/`$\kappa_1$`]) `$\circ$` [`$X\mapsto\kappa_1$`]
				else `$fail$`
	\end{lstlisting}
	注意基于流属性的类型系统不支持递归类型，所以如果检测到变量$X$应该替换为$\kappa$且$X$在$\kappa$中自由出现则会直接报错。
	
	\subsection{求解子类型约束集合}
	对于一个形如$\{\kappa_1\preceq\kappa_2, \kappa_3\preceq\kappa_4\cdots\}$子类型约束集合$C$, 我们首先需要将其转化为形如$\{\ell_1\subseteq\ell_2, \ell_3\subseteq\ell_4\cdots\}$的流属性约束集合，转换的算法伪代码描述如下：
	\begin{lstlisting}[escapeinside={`}{`}]
	trans(D) = if D is empty then `$\emptyset$`
			else let {d} `$\cup$` D' = D in
			if d = `$Bool^{\ell_1} \preceq Bool^{\ell_2}$` 
				then trans(D') `$\cup$` subset(`$\ell_1, \ell_2$`)
			if d = `$Int^{\ell_1} \preceq Int^{\ell_2}$`
				then trans(D') `$\cup$` subset(`$\ell_1, \ell_2$`)
			if d = `$\kappa_1\xto{\ell_1}\kappa_2\preceq\kappa_3\xto{\ell_2}\kappa_4$`
				then trans(D'`$\cup\{\kappa_3\preceq\kappa_1\}\cup\{\kappa_2\preceq\kappa_4\}$`) `$\cup$` subset(`$\ell_1, \ell_2$`)
			if d = `$(\kappa_1, \kappa_2)^{\ell_1}\preceq(\kappa_3, \kappa_4)^{\ell_2}$`
				then trans(D'`$\cup\{\kappa_1\preceq\kappa_3\}\cup\{\kappa_2\preceq\kappa_4\}$`) `$\cup$` subset(`$\ell_1, \ell_2$`)
	\end{lstlisting}
	subset函数用于生成一个流属性约束集合，定义如下, 其中$\alpha, \beta$代指流属性变量，$\ell$指流属性：
	\begin{align*}
		subset(\alpha, \beta) &= \alpha\subseteq\beta\\
		subset(\ell, \beta) &= \ell\subseteq\beta\\
		subset(\ell, \ell') &= \emptyset&\text{if}\quad \ell\subseteq\ell'\\
		subset(\ell, \ell') &= fail&\text{if}\quad \ell\not\subseteq\ell'\\
		subset(\alpha, \ell) &= fail
	\end{align*}
	\subsection{求解流属性约束集合}
	一个形如$\mathcal{D} = \{\alpha\subseteq\beta, \ell\subseteq\gamma, \cdots\}$的集合被称为流属性约束集合，其中每一条约束$\alpha\subseteq\beta$的含义为流属性$\alpha$是$\beta$的真子集。我们希望找到一个从流属性变量映射到流属性的函数$\mathcal{F}$，使得对于所有的约束$\alpha\subseteq\beta$都有$\mathcal{F}(\alpha)\subseteq\mathcal{F}(\beta)$. 
	
	为了求解流属性约束集合，我们可以将其抽象为一个图论问题。构建有向图$G = (V, E)$，其中$V$为流属性约束集合$\mathcal{D}$中所有出现的流属性变量，$E = \{(\beta, \alpha)\ \mid\ \{\alpha\subseteq\beta\}\subseteq\mathcal{D}\}$. 	有向图$G$中一条边$(\alpha, \beta)$的含义为，流属性变量$\beta$所代表的流属性是$\alpha$所代表的流属性的子集。同时定义从$V$映射到流属性的函数$\mathcal{H}$:
	\begin{equation*}
		\mathrm{H}(\alpha) = \bigcup\ell\qquad\forall\{\ell\subseteq\alpha\}\subseteq\mathcal{D}
	\end{equation*}
	
	$\mathcal{H}$函数的含义为$\mathcal{H}(\alpha)$是流属性变量$\alpha$所代表的流属性的子集. 于是可以发现，$\mathcal{F}(\alpha)$实际上是$\alpha$节点所有可以到达的节点的$\mathcal{H}$函数值的并集。于是一个朴素的算法为对于每一个节点$\alpha$，从它为起点进行一遍图的深度优先遍历，记录所有到达的节点，然后计算出这些节点的$\mathcal{H}$函数值并将其取并就可以计算出$\mathcal{F}$。但是这个算法需要对于图中每一个节点都进行深度优先遍历，每次深度优先遍历的时间复杂度为线性，所以总的时间复杂度是平方级别。这个算法在项目规模不大的时候运行时间尚能接受，但是对于规模较大的项目，我们就必须寻找更优的算法。
	
	我们从一个特殊情况开始考虑：如果$G$中的边没有形成环，即$G$是一个有向无环图，是否有更优的算法。实际上，对于这种特殊情况，我们可以使用动态规划的算法解决。我们按照出度对图$G$进行拓扑排序，令$v_1, v_2, \cdots, v_n$是$G$的拓扑序列，即对于任意$v_i$，如果$(v_i, v_j) \in E$,　则必有$j < i$. 我们可以从前向后处理整个序列，对于当前的$v_i$, 找到其出边对应的所有$v_j$。由于是拓扑序列，$\mathcal{F}(v_j)$一定已经被计算出了，于是直接令$\mathcal{F}(v_i) = \bigcup\mathcal{F}(v_j),\quad\forall(v_i, v_j)\in E$ 即可。
	
	对于图$G$是一般图的情况，我们可以使用极大强连通分分量的算法进行解决。一个有向图$G = (V, E)$的一个强连通分量定义为$V$的一个子集$V'$使得对于任意$V'$中两个节点$v_i, v_j$，它们均可以互相到达。而一个极大强连通分量即为一个强连通分量$V'$，且对于任意$v'\in V - V'$, $V'\cup\{v'\}$都不是强连通分量。由于强连通分量的定义，我们可以发现对于属于同一强连通分量的中的两个节点$v_i$和$v_j$，必有$\mathcal{F}(v_i) = \mathcal{F}(v_j)$, 于是我们可以对于一个强连通分量，只计算一个$\mathcal{F}$即可. 对于有向图$G = (V, E)$, 我们可以使用Tarjan算法在线性时间内将$V$划分为若干个极大强连通分量的并集，即$V = V_1\cup V_2\cup \cdots\cup V_k$且$\forall i, j \in [1, k], i \not= j, V_i\cup V_j = \emptyset$. 求得极大强连通分量之后，我们构建新图$G' = (V', E')$, 其中$V' = \{V_1, V_2, \cdots, V_k\}$, $E' =  \{(V_i, V_j)\ \mid\ \exists v_i\in V_i\ \exists v_j\in V_j\ s.t.\ (v_i, v_j)\in E\}$, 容易发现$G'$是有向无环图（如果不然，可以将其环上的节点求并从而得到一个更大的强连通分量），于是可以套用上文中有向无环图的算法求得新图中每个节点的$\mathcal{F}$函数，然后原图中每个节点的$\mathcal{F}$值即为对应的极大强连通分量的$\mathcal{F}$值。Tarjan算法运行时间为线性，在有向无环图中求$\mathcal{F}$函数的时间复杂度也是线性，所以总的时间复杂度是线性。
	
	\subsection{算法总结}
	给定待分析的表达式$e$，首先使用3.5章的类型推导规则推导出$e$的流属性类型$\kappa$，与此同时得到其类型约束集合$D$和子类型约束集合$C$。然后使用3.6中的算法求解类型约束集合，得到解$S$。将类型约束集合的解$S$应用到子类型约束集合$C$得到$C'$。接下来使用3.7中的算法将子类型约束集合转换为流属性约束集合$\mathcal{D}$, 再利用3.8中的算法求解流属性约束集合$\mathcal{D}$得到其解函数$\mathcal{F}$. 于是对于$e$中任意一子表达式$e'$，且$e'$有流属性类型$\kappa'$。那么$\ell = \mathcal{L}(\mathcal{F}(S(\kappa')))$就是$e'$的流属性，即$e'$最终可能求值结果的标号是$\ell$的一个子集。
\end{document}